(def! defn! (macro (fn*
    [name params & body]
    `(def! ~name (fn* ~params ~@body)))))

(def! defmacro! (macro (fn*
    [name params & body]
    `(def! ~name (macro (fn* ~params ~@body))))))

(defmacro! cond
    [& xs]
    (if (not (empty? xs))
        (list 'if (fst xs)
            (if (gt (len xs) 1)
                (nth xs 1)
                (throw "odd number of forms to cond"))
            (cons 'cond (rest (rest xs))))
        nil))

(defn! include
    [src & rest]
    (def! params (or (fst rest) {}))
    (if (snd rest)
        (throw "too many arguments")
        ())
    (def! e (env/sets (new-env) params))
    (load-shtml e src))

(defn! x@include
    [params children]
    (def! params (map/take params 'src))
    (include (fst params) (snd params)))

(defn! import-file [path] (load-mal (new-env) path))

(defmacro! import!
    [path & args]

    (defn! name-from-path
        [path]
        (def! path (snd (or (string/rsplit path "/") [nil path])))
        (fst (or (string/split path ".") [path nil])))

    ; Get the name of the binding
    (def! name (cond
        ; Get the 'as [NAME]' term if it is present
        (and (= (len args) 2)
             (= (fst args) 'as))
            (snd args)
        
        ; Get the filename if alias is not specified
        (= (len args) 0) (name-from-path path)

        ; Else just crash
        true (throw "bad arguments")))
    
    ; Read and evaluate the file in a new environment
    (def! value (import-file path))

    ; Set name to the evaluated value
    `(def! ~(sym name) ~value))

(defmacro! #
    [& xs]
    `(do (~@xs) nil))

(defn! fold
    [xs f]
    (if (= (len xs) 0)
        '()
        (f (fold (rest xs) f) (fst xs))))

(defn! filter
    [xs f]
    (fold xs (fn*
        [rest fst]
        (if (f fst)
            (cons fst rest)
            rest))))

(defn! map
    [xs f]
    (fold xs (fn*
        [rest fst]
        (cons (f fst) rest))))